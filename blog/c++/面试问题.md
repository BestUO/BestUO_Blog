[TOC]
# 面试问题整理

## 知识点
### 缓存一致性协议
伪共享，c++6中内存模型
```
enum memory_order {
    memory_order_relaxed,
    memory_order_consume,
    memory_order_acquire,
    memory_order_release,
    memory_order_acq_rel,
    memory_order_seq_cst
};
```
### 实时操作系统分时操作系统
cpu处理完当前指令才能处理下一个，cpu时间片轮转分时
### 中断机制
分硬中断软终端，机制一样。
* 中断请求阶段
* 中断判优阶段
* 中断响应阶段
	- 保护硬件现场
	- 获得中断服务程序的入口地址
* 中断服务阶段
	- 中断服务程序
	- 恢复现场
* 中断返回阶段
### 进程通信
[pipe](https://blog.csdn.net/u014630983/article/details/127826831)，socket，共享内存mmap
### 进程同步互斥
[信号量Semaphore](https://blog.csdn.net/weixin_50941083/article/details/122573837)
### 线程防止死锁
* 注意加锁释放锁的顺序
* 如果有锁依赖不能构成环
* 因业务缓慢造成的死锁考虑使用延时锁timed_mutex
### 进程线程的切换过程
线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。
* 保存程序计数器和寄存器（进程切换需要保存虚拟内存空间）
* 恢复带运行线程的程序计数器和寄存器
* 跳转到程序计数器指向位置完成切换
### 请简述 epoll
epoll惊群问题
epoll_create/epoll_ctl/epoll_wait
LT (level triggered) 是缺省的工作方式水平触发
ET (edge-triggered) 是高速工作方式边缘触发
完成多路复用，之后为了高效使用异步io，read、write返回-1之后判断eagain
### 多态的实现原理
通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。
### 两个线程能不能通过while(!ptr)判断new完成
new包括分配内存和placement new两个阶段，两个阶段非原子操作
### 单链表，取倒数第n个节点
使用vetcor，双指针
### std::move实现
```
template<typename _Tp>
struct remove_reference
{ typedef _Tp   type; };
 
// 特化版本
template<typename _Tp>
struct remove_reference<_Tp&>
{ typedef _Tp   type; };
 
template<typename _Tp>
struct remove_reference<_Tp&&>
{ typedef _Tp   type; };

template <class _Ty>
_NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}
```
### 生成唯一短url
短url服务起负责转换到长url，采用base62编码，6位short url看做一个 62 进制数（0-9,a-z,A-Z)，每个short url对应到一个整数，该整数对应 DB 表的主键。
### 设计模式
#### 工厂模式
场景：多类型外呼任务
#### 单例模式
#### 代理模式
数据库模块
#### 策略模式
日志删除策略
#### 装饰器模式
std::function作为形参
### tcp传输
如何解决丢包
如何解决先后顺序 延时发送
如何解决重传数据
如何确认数据
拥塞控制 
### 可靠udp传输
udp server 是否针对大量客户端同时发送
又没有可能出现脏数据
QUIC
[kcp](https://vearne.cc/?s=kcp)
[如何实现可靠性的UDP协议（三大方式RUDP、RTP、UDT](https://www.codenong.com/cs106647398/)
upd一次传输字节数<=mtu 1472
### std::future/std::packaged_task
### maloc
<128k 使用brk在堆上分配
申请内存>=128k 使用mmap在文件映射段分配，由高地址到低址值
brk 缺页异常 页面置换算法
### enable_shared_from_this
### asio
asio::async_write不能异步调用
### 环形无锁队列
多入多出的情况下头尾节点都需要tail，head指针。因为是环形队列，所以数据的拷贝和指针的移动不是原子操作。在单入单出的情况下可以先拷贝数据，在移动指针。但是在多入多出的情况下需要先移动head指针，拷贝数据，再移动tail指针。移动head指针为了锁住另一个消费者，移动tail指针是为了让生产者知道数据可用。
### char* 和char[]
```char *a```存储在静态常量区，```char c[]```在栈区 所以输出10
```
int main()
{
    char *a="abc";
    char *b="abc";
    char c[]="abc";
    char d[]="abc";
    if(a==b)
        std::cout << 1 << std::endl;
    else
        std::cout << 0 << std::endl;
    if(c==d)
        std::cout << 1 << std::endl;
    else
        std::cout << 0 << std::endl;

    return 0;
}
```
### 为什么函数参数从右往左入栈
为了支持可变长参数特性，表示参数长度等的固定部分放在栈顶，就能确定剩下参数的个数
### restfulapi设计规范
#### 每一个URI代表一种资源
url设计：http://域名/版本号/资源

- GET (SELECT): 查询；从服务器取出资源.
- POST(CREATE): 新增; 在服务器上新建一个资源。
- PUT(UPDATE): 更新; 在服务器上更新资源(客户端提供改变后的完整资源)。
- PATCH(UPDATE): 更新；在服务器上更新部分资源(客户端提供改变的属性)。
- DELETE(DELETE): 删除; 从服务器上删除资源。
#### 同一种资源有多种表现形式(xml/json)
#### 返回一致的数据格式。
RESTful规范中的请求应该返回统一的数据格式。对于返回的数据，一般会包含如下字段:

- code: http响应的状态码。
- status: 包含文本, 比如：'success'(成功), 'fail'(失败), 'error'(异常) HTTP状态响应码在500-599之间为 'fail'; 在400-499之间为 'error', 其他一般都为 'success'。对于响应状态码为 1xx, 2xx, 3xx 这样的可以根据实际情况可要可不要。
- data: 当请求成功的时候, 返回的数据信息。但是当状态值为 'fail' 或 'error' 时，data仅仅包含错误原因或异常信息等。
### 查看进程句柄
查看当前进程的打开文件数量：```lsof -p pid | wc -l ```
严格说```lsof -p pid | wc -l```查询的数据不准确，里面含有重复的句柄文件数，已经mem占用也包含了
### 代码设计原则
总的说就是去耦合，包括

- 面向接口编程
- 开闭原则，一个类只扩展，不修改代码
- 一个方法只实现一种功能