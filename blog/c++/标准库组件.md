[TOC]
# 好用的标准库组件
**<font color='red'>！！！不定时更新！！！</font>**
## std::optional
管理一个可选的容纳值，既可以存在也可以不存在的值。通常用在通过flag判断值是否有意义的场景。
```c++
struct TT
{
    int aaa=0;
};
std::tuple<bool,TT> getstruct(bool flag)
{
	if(flag)
		return std::tuple<bool,TT>{true,{1}};
	else
		return std::tuple<bool,TT>{false,{}};
}
auto [flag.a]=getstruct(true);
if(flag)
    std::cout << a.aaa << std::endl;

//使用optional可以改写为
std::optional<TT> getstruct(bool flag)
{
	if(flag)
		return TT{1};
	else
		return std::nullopt;
}
auto a=getstruct(true);
if(a)
    std::cout << (*a).aaa << std::endl;
```

## std::variant
更安全的union
```c++
std::variant<std::monostate, int, double, std::string> x;
x = 1;
int* i = std::get_if<int>(&x);
if (i == nullptr)
    std::cout << "wrong type" << std::endl;
x = 1.1;
i = std::get_if<int>(&x);
if (i == nullptr)
    std::cout << "wrong type1.1" << std::endl;
```

## concept、requires
约束模板或者指定模板必须满足某些条件 https://blog.csdn.net/johnnymartin/article/details/123972055 https://blog.csdn.net/guxch/article/details/110795047 https://blog.csdn.net/qq_42896106/article/details/125341828
```c++
//约束T的四种方式,后两种方便组合多个require子句
template<my_concept T>
void func(T t);

void func(my_concept t);

template<typename T> requires my_concept<T>
void func(T t);

template<typename T> 
void func(T t) requires my_concept<T>;
```
定义concept、requires
```c++
//一般的：
template<typename T>
concept IntorFloat=std::integral<T> || std::floating_point<T>;

//加上requirements：
template <class T>
concept Semiregular = std::destructible<T> && requires(T a, size_t n) {  
    a();                //simple
    requires std::same_as<T*, decltype(&a)>;        // nested: "Same<...> evaluates to true"
    { a.~T() } noexcept;    // compound: "a.~T()" is a valid expression that doesn't throw
    { delete new T[n] };    // compound
};

//类型约束以typename开头紧跟类型名
template<typename A>
concept Awaitable = requires {
    typename detail::GetAwaiter_t<A>;
}
```

## std::declval和std::decltype
[杜紫童这篇很好，总结如下](https://www.zhihu.com/question/447107869/answer/1757635568)
decltype是根据变量获得其类型```using type = decltype(a)```，std::declval是根据类型获得基变量```auto&& a = std::declval<type>()```
比如有两个类如下：
```c++
struct device1
{
	int get_id() const
	{
		return 1;
	}
	std::string get_name() const
	{
		return "device1"s;
	}
};

struct device2
{
	int get_id() const
	{
		return 2;
	}
};
```
假设在输出日志时，对某一种device，有get_name时，输出其返回值；否则，输出其id，即get_id。在使用静态多态的前提下，要实现该功能，需要一些辅助工具，将会用到decltype和std::declval：
```c++
// 注意 std::void_t 需要 C++14
template<class T, class=void>
struct has_get_name :std::false_type
{};

template<class T>
struct has_get_name<T, std::void_t<decltype(std::declval<T>().get_name())>> :std::true_type
{};
```
此时
```c++
constexpr auto b1 = has_get_name<device1>::value; // true
constexpr auto b2 = has_get_name<device2>::value; // false
```
然后简单粗暴（SFINAE）地使用两个模板来得到输出的内容：
```c++
template<class T, typename std::enable_if<has_get_name<T>::value, int>::type = 0>
std::string make_name(const T& device)
{
	return device.get_name();
}

template<class T, typename std::enable_if<!has_get_name<T>::value, int>::type = 0>
std::string make_name(const T& device)
{
	return "device (id: "s + std::to_string(device.get_id()) + ")"s;
}

// result
device1 d1;
device2 d2;
auto name1 = make_name(d1); // "device 1"
auto name2 = make_name(d2); // "device (id: 2)"
```
到了C++20，通过Concept，可以更简单地搞SFINAE了。
```c++
// C++20
template<class T>
concept has_get_name = requires(T a) { a.get_name(); };

template<class T>
concept has_no_get_name = !has_get_name<T>;

template<has_get_name T>
std::string make_name(const T& device)
{
	return device.get_name();
}

template<has_no_get_name T>
std::string make_name(const T& device)
{
	return std::format("device (id: {})", device.get_id());
}
```
如果搭配上C++17的constexpr if，代码会更简单：
```c++
template<class T>
concept has_get_name = requires(T a) { a.get_name(); };

template<class T> 
std::string make_name(const T& device)
{
	if constexpr (has_get_name<T>)
	{
		return device.get_name();
	}
	else
	{
		return std::format("device (id: {})", device.get_id());
	}
}
```

## std::apply
https://blog.csdn.net/fl2011sx/article/details/119217893

## std::make_index_sequence和std::index_sequence
https://www.lmlphp.com/user/152113/article/item/3781531/

## 模板特化和偏特化
```c++
//通例
template  <class T, class K>
class Test 
{};
//特化
template  <class T, class K>
class Test<bool,int>
{};
//偏特化
template  <class K>
class Test<bool,K>
{};
```

## 推导指南 Deduction Guides
https://blog.csdn.net/weixin_40539125/article/details/106044614 https://blog.csdn.net/janeqi1987/article/details/100211442
如果使用模板名称创建对象，但未指定任何模板参数，则编译器将构建一个虚构的“构造函数模板”集，称为推导指南。
```c++
// 定义一个模板 SS     (1)
template<typename T>
struct SS { T t; };

// 定义两个 deduction guides
SS(double) -> SS<double>;                                   // (2)
SS(std::pair<int, int>) -> SS<std::pair<int, int>>;         // (3)

// 按主模板 (1) 进行推导, s1 的类型为 SS<int>
SS s1{1};

// 按 (2) 进行推导, s2 的类型为 SS<double>
SS s2{1.5};

// 按 (3) 进行推导, s3 的类型为 SS<std::pair<int, int>>
std::pair<int, int> p{1,2};
SS s3{p};
//非模板推导指南
template<typename T>
struct S 
{
    T val;
};
 
S(const char*) -> S<std::string>; // 从const char*推断为std::string
```