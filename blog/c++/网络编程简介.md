[TOC]

# select,epoll,asio用法简单介绍

## select
轮询所有套接字集合，并将有响应的套接字取出放入对应待处理的集合中处理。因为采用轮询的机制，因此不是一个最优解。并且select模型的默认文件描述符个数上线为1024，这是一个大坑。
select模型常用结构体、函数如下：
```
typedef struct fd_set {
        u_int fd_count;               /* how many are SET? */  有多少套接字
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */ 套接字的数据
} fd_set;

int WSAAPI select(
  int           nfds,            //默认为0
  fd_set        *readfds,        //一个指针集合.. 针对读操作 accept,recg
  fd_set        *writefds,       //针对写操作 connect send
  fd_set        *exceptfds,      //针对出现的异常
  const timeval *timeout         //超时设置,为NULL就是一直等待结果.
);
返回值:
　　1超时返回0
　　2.出错返回 SOCKET_ERROR

void FD_ZERO(fd_set *set)			用于清空 fds 里存储的 fd，一般在初始化时清空 fds 。
void FD_SET(int fd, fd_set *set)	用于向 fds 里添加一个 fd 。
void FD_CLR(int fd, fd_set *set)	用于从 fds 里清除一个 fd 。
int FD_ISSET(int fd, fd_set *set)	用于判断 fd 是否在 fds 里，一般在 select() 调用结束之后使用。
```

## epoll
### 核心结构体和函数
```
int epoll_create(int size);               //创建一个epoll句柄，size只需大于0

int epoll_ctl(                            //监听的事件类型
  int epfd,                               //epoll_create()的返回值
  int op,                                 //EPOLL_CTL_ADD：注册新的fd到epfd中|EPOLL_CTL_MOD：修改已经注册的fd的监听事件|EPOLL_CTL_DEL：从epfd中删除一个fd
  int fd,                                 //需要监听的fd
  struct epoll_event *event);             //需要监听的事件


typedef union epoll_data
{
 void *ptr; /* Pointer to user-defind data */
 int fd; /* File descriptor */
 uint32_t u32; /* 32-bit integer */
 uint64_t u64; /* 64-bit integer */
} epoll_data_t;
struct epoll_event {
__uint32_t events;                        /* Epoll events /
epoll_data_t data;                        / User data variable */
};
events可以是以下几个宏的集合：
EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT：表示对应的文件描述符可以写；
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR：表示对应的文件描述符发生错误；
EPOLLHUP：表示对应的文件描述符被挂断；
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。

int epoll_wait(                           //等待事件的产生
  int epfd,                               //epoll_create()的返回值
  struct epoll_event *evlist,             //x指向绪态文件描述符的信息
  int maxevents,                          //evlist长度
  int timeout);                           //-1：一直阻塞知道捕获型号|0：执行一次非阻塞式地检查查看有哪些事件|>0：阻塞至多timeout毫秒
```
### 触发方式
当一次read()读取没有读取完缓冲区中的数据时
#### 水平触发
LT，此时缓冲区中还有数据，会继续发通知，因此会占用内核资源
#### 边沿触发
ET，此时缓冲区状态并没有发生变化，并没有来新的数据就不会发通知，因此需要循环读取数据，直到缓冲区中的数据全部读取完成。有效减少epoll_wait/epoll_pwait调用，提高应用程序效率。
### [epoll惊群](https://zhuanlan.zhihu.com/p/359774959)
* linux4.5内核之后给epoll添加了一个EPOLLEXCLUSIVE的标志位
* linux 3.9内核之后给socket提供SO_REUSEPORT标志
### 参考
* [官方demo](https://man7.org/linux/man-pages/man7/epoll.7.html)
* [深入了解epoll模型](https://zhuanlan.zhihu.com/p/427512269)
* [彻底弄懂EPOLLOUT事件](https://blog.csdn.net/CODINGCS/article/details/115046256)
* [簡約而不簡單epoll之EPOLLOUT](https://www.twblogs.net/a/5eef58081f92b2f1a17d042c)
* [EPOLLET模式下的正确读写方式](https://blog.csdn.net/daiyudong2020/article/details/50459215)
* [epoll select的限制 条件触发 边缘触发](https://blog.csdn.net/dashoumeixi/article/details/85255073)
* [边缘模式EPOLLET EPOLLOUT简单例子](https://blog.csdn.net/dashoumeixi/article/details/94406535)

## asio
[code](https://github.com/BestUO/littletools)
### socket相关
[官方example](https://think-async.com/Asio/asio-1.24.0/doc/asio/examples/cpp11_examples.html)
### make_work_guard/restart/run/poll/dispatch/post
* 当io_context没有数据时io_context.run()会自动结束，同时置stopped_=true。导致之后增加的任务无法运行。可设置make_work_guard保持io_context.run()一直运行，或调用io_context.restart()重置stopped_。
* io_context.run()和io_context.poll()功能相似都是消费任务队列，区别是io_context.run()会阻塞当前线程，而io_context.poll()不会。
* 当io_context.dispatch()和io_context.run()处于同一线程时，直接调用handler。
```
void test()
{
    asio::io_context ios;

    uint16_t s = 0;
    while (++s)
    {
        ios.post([s]()
        {   cout<<s; cout.flush();});
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
        ios.restart(); // 注意调restart，设置stopped_=false否则后面的回调都不会执行
        ios.poll();  // poll不会阻塞，可以在自己的主循环里面调用
    }
}

void test()
{
    asio::io_context io_context;
    uint16_t s = 0;
    //使用make_work_guard保证io_context不退出
    auto worker = asio::make_work_guard(io_context);

    std::thread t2([&io_context](){ io_context.run(); });
    std::thread t([&io_context,&s]()
    {
        while (++s)
        {
            //post到t2中执行
            io_context.post([&io_context]()
            {
                //继续post回调函数
                io_context.post([]()
                {
                    cout<<"post will run after all dispatch, threadid:"<<std::this_thread::get_id()<<"\n";
                });
                //dispatch方法和run方法在同一线程，直接执行回调函数
                io_context.dispatch([]()
                {
                    cout<<"dispatch1 will run first, threadid:"<<std::this_thread::get_id()<<"\n";
                });
                io_context.dispatch([]()
                {
                    cout<<"dispatch2 will run first, threadid:"<<std::this_thread::get_id()<<"\n";
                });
            });
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    });

    t2.join();
    t.join();  
}
```
### asio::threadpool
* 通过scheduler实现的一个线程池
```
void test()
{
    asio::thread_pool io(1);
    //io.join(); need call in Destructor

    uint16_t s = 0;
    std::thread t([&s](){
    while (++s)
    {
        //post使用方法
        asio::post([s]()                     
        {   
            cout<<s; cout.flush();
        });
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }});
    t.join();
}
```
### asio::strand
一个io_context在多个线程中run，此时提交的起步请求会在任意run线程中执行。代入到网络模型中，极有可能出现同一个clientsocket，他的async_read_some和async_write在不同线程中执行导致出错。因此可以通过strand保证同一个socket读写操作的顺序执行。
```
void strandtest()
{
    asio::io_context io_context;
    auto worker = asio::make_work_guard(io_context);

    std::vector<std::thread> runthreads;
    for(int i=0;i<3;i++)
        runthreads.emplace_back(std::thread([&io_context](){ io_context.run(); }));
    auto fun1 = []()
    {
        std::cout<< "fun1 " << std::this_thread::get_id()<<std::endl;
    };
    auto fun2 = []()
    {
        std::cout<< "fun2 " << std::this_thread::get_id()<<std::endl;
    };
    {
        //乱序
        for(int i = 0;i<10;i++)
        {
            asio::post(io_context,fun1);
            asio::post(io_context,fun2);
        }
    }
    sleep(5);
    std::cout << "use strand" << std::endl;
    {
        //顺序绑定strand
        asio::strand<asio::io_context::executor_type> fun1strand(asio::make_strand(io_context));
        asio::strand<asio::io_context::executor_type> fun2strand(asio::make_strand(io_context));

        for(int i = 0;i<10;i++)
        {
            asio::post(asio::bind_executor(fun1strand,fun1));
            asio::post(asio::bind_executor(fun2strand,fun2));
        }
    }

    for(auto &tmp:runthreads)
        tmp.join();
}
```
### steady_time
使用wait()接口为同步定时器，使用async_wait()为异步定时器
```
void steadytimertest()
{
    asio::io_context ioc;
    asio::steady_timer timer(ioc, std::chrono::seconds(3));
    int count = 0;
    timer.async_wait(std::bind(&Print,std::placeholders::_1, &timer, &count));
    ioc.run();
}
```
### buffer/streambuf
* asio::buffer本身并不申请内存，只是提供了一个对现有内存的封装
* asio::streambuf提供了一个流类型的buffer，它自身根据需要动态申请内存的
```
///////////////////asio::buffer//////////////////////
char d1[128];
size_t bytes_transferred = sock.receive(asio::buffer(d1)); //char转buffer
string str = " hello world " ;
size_t bytes_transferred = sock.send(asio::buffer(str));    //string转buffer
char* p1 = asio::buffer_cast<char*>(buffer);                //buffer转char
size_t s1 = asio::buffer_size(buf);                         //获取buffer长度
///////////////////asio::streambuf///////////////////
void streambuffertest()
{
    asio::streambuf write_buffer;
    std::ostream output(&write_buffer);
    output << "a@"
            "b@";
    std::cout << "Wrote: " << make_string(write_buffer) << std::endl;

    write_buffer.consume(2);
    std::cout << "Consumed write buffer, it now contains: " <<
                    make_string(write_buffer) << std::endl;
}
```
### coroutine
协程简介请跳转至：[c++20_Coroutines入门](http://www.aiecent.com/articleDetail?article_id=47) [开源协程库](http://www.aiecent.com/articleDetail?article_id=46) [netcan_asyncio学习](http://www.aiecent.com/articleDetail?article_id=50) [asio协程官方用例](https://think-async.com/Asio/asio-1.24.0/doc/asio/examples/cpp20_examples.html)
```
awaitable<void> echo(tcp::socket socket)
{
  try
  {
    char data[1024];
    for (;;)
    {
      std::size_t n = co_await socket.async_read_some(asio::buffer(data), use_awaitable);
      co_await async_write(socket, asio::buffer(data, n), use_awaitable);
    }
  }
  catch (std::exception& e)
  {
    std::printf("echo Exception: %s\n", e.what());
  }
}

awaitable<void> listener()
{
  auto executor = co_await this_coro::executor;
  tcp::acceptor acceptor(executor, {tcp::v4(), 55555});
  for (;;)
  {
    tcp::socket socket = co_await acceptor.async_accept(use_awaitable);
    co_spawn(executor, echo(std::move(socket)), detached);
  }
}

int coroutinuec20()
{
  try
  {
    asio::io_context io_context(1);

    asio::signal_set signals(io_context, SIGINT, SIGTERM);
    signals.async_wait([&](auto, auto){ io_context.stop(); });

    co_spawn(io_context, listener(), detached);

    io_context.run();
  }
  catch (std::exception& e)
  {
    std::printf("Exception: %s\n", e.what());
  }
  return 0;
}
```
### 参考
* [官网介绍](https://think-async.com/Asio/asio-1.24.0/doc/asio/overview.html)
* [asio随笔](https://www.cnblogs.com/ylcc-zyq/category/1994149.html)
* [Asynchronous I/O with C++](https://dens.website/tutorials/cpp-asio)
* [boostasiostreambuf](https://stackoverflow.com/questions/28478278/working-with-boostasiostreambuf)
* [C++网络编程之ASIO](https://github.com/khan-lau/blog/blob/main/C++%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BASIO.md)
* [Boost.Asio](https://theboostcpplibraries.com/boost.asio)
* [io_context多线程](https://blog.csdn.net/vaughn0223/article/details/126938109)
* [Boost.Asio入门](https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/Chapter1.html)
* [BoostAsioCppNetworkProgrammingCookbookDmitroRadchuk](https://github.com/Belgorodsky/BoostAsioCppNetworkProgrammingCookbookDmitroRadchuk)
* [如何学习和使用asio 网络库](https://blog.csdn.net/v6543210/article/details/121647671)
* [demo](https://github.com/franktea/network)