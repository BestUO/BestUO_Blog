[TOC]
# C++工具技巧1

## 单元测试工具
### doctest
[repository](https://github.com/doctest/doctest/blob/master/doc/markdown/tutorial.md	)
[demo](https://github.com/BestUO/littletools/blob/master/examples/tooltest.cpp)
```C++
TEST_CASE("testing TimerManager AddAlarm DeleteAlarm") 
{
    struct Key
    {
        std::string name;   
        int id;
    };

    auto fun2 = [](int a, int b)
    {
        std::cout << a << '\t' << b << std::endl;
    };
    TimerManager<Key> *tm = TimerManager<Key>::GetInstance();
    for(int i=5;i<10;i++)
        tm->AddAlarm(std::chrono::system_clock::now()+std::chrono::seconds(2), Key{"123",i}, std::bind(fun2,i,i+1));
    CHECK(tm->DeleteAlarm(std::bind([](const Key& t, int id){ return t.id == id; },std::placeholders::_1, 7)) == true );
    sleep(3);
    tm->StopTimerManager();
}

/*
output:
[doctest] doctest version is "2.4.9"
[doctest] run with "--help" for options
5       6
6       7
8       9
9       10
===============================================================================
[doctest] test cases: 1 | 1 passed | 0 failed | 0 skipped
[doctest] assertions: 1 | 1 passed | 0 failed |
[doctest] Status: SUCCESS!
*/
```
	
## 内存泄露
### valgrind
[Valgrind Documentation](https://valgrind.org/docs/manual/manual.html)	
* memcheck:检查程序中的内存问题，如泄漏、越界、非法指针等
```
valgrind --log-file=valgrind.log --tool=memcheck --leak-check=full ./your_app arg1 arg2
```
https://www.jianshu.com/p/78adaba826c3	
* massif:堆栈分析器，指示程序中使用了多少堆内存等信息
```
堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。Massif能帮助我们减少内存的使用，
在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。
```

## 性能分析
### 在线耗时分析
* https://quick-bench.com/q/bLmEQIyt-7utcuY8_m1aWRyBg_M
* https://www.perfbench.com/
### 本地耗时分析
#### [nanobench](https://github.com/martinus/nanobench)
```c++
ankerl::nanobench::Bench().run("DeleteAlarm cost time",[&]()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
});

/*
output:
Recommendations
* Use 'pyperf system tune' before benchmarking. See https://github.com/psf/pyperf

|               ns/op |                op/s |    err% |     total | benchmark
|--------------------:|--------------------:|--------:|----------:|:----------
|      100,141,400.00 |                9.99 |    0.0% |      1.10 | `DeleteAlarm cost time`
*/
```
#### valgrind
[Valgrind Documentation](https://valgrind.org/docs/manual/manual.html)

* callgrind:检测程序代码的运行时间和调用过程，以及分析程序性能
```
valgrind --tool=callgrind --dump-instr=yes --trace-jump=yes --separate-threads=yes ./your_app arg1 arg2
separate-threads	会为每个线程单独生成一个性能分析文件	
dump-instr=yes		可产生指令级的信息，该信息可以用kcachegrind可视化	
trace-jump=yes		或许应该写成:--collect jump=yes 用于分析更加详细的jump信息	

如果出现：valgrind: failed to start tool 'callgrind' for platform 'amd64-linux': Not a directory
# whereis valgrind
# export VALGRIND_LIB=/usr/local/bin/valgrind

//使用callgrind_annotate --auto=yes callgrind.out.38031 >log分析文件
353,327,364  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir           file:function
--------------------------------------------------------------------------------
159,533,000  ???:__sin_avx [/usr/lib64/libm-2.17.so]
148,423,000  ???:__cos_avx [/usr/lib64/libm-2.17.so]
 14,377,990  ???:for_loop() [/root/test]
 14,300,004  ???:__gnu_cxx::__enable_if<std::__is_integer<int>::__value, double>::__type std::cos<int>(int) [/root/test]
 14,300,004  ???:__gnu_cxx::__enable_if<std::__is_integer<int>::__value, double>::__type std::sin<int>(int) [/root/test]

//或者使用gprof2dot.py图像化分析：
pip install gprof2dot
gprof2dot -f callgrind -n10 -s callgrind.out.38031 > callgrind.dot
dot -Tpng callgrind.dot -o callgrind.png
```
<center>![](http://www.aiecent.com/img/valgrind.png)</center>

* cachegrind:分析CPU的cache命中率、丢失率，用于进行代码优化	
```
valgrind –tool=cachegrind ./your_app arg1 arg2
```
* heigrind:用于检查多线程程序的竞态条件。
```
/*
它主要用来检查多线程程序中出现的竞争问题。Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，
这些区域往往是线程之间失去同步的地方，而且会导致难以发觉的错误。Helgrind实现了名为Eraser的竞争检测算法，
并做了进一步改进，减少了报告错误的次数
*/
valgrind --tool=helgrind ./your_app arg1 arg2
```

#### gperftools
加上-lprofiler对程序重新编译一次，再执行程序就可以了，否则需要修改代码

* 性能分析
    - https://blog.csdn.net/10km/article/details/83820080
    - https://www.cnblogs.com/gnivor/p/11719958.html
    - https://blog.51cto.com/wulingdong/2043898
* 内存分析
    - https://blog.csdn.net/chen134225/article/details/126316536
    - https://daiwk.github.io/posts/knowledge-gperftools.html 

#### perf
[简单介绍1](https://blog.csdn.net/runafterhit/article/details/107801860)
[简单介绍2](https://blog.csdn.net/jasonactions/article/details/109332167)

* 安装
    - apt-get install linux-perf
    - mv /usr/bin/perf_5.10 /usr/bin/perf_5.10.16
* 使用
    - 编译二进制
        + g++ -g a.cpp -o a
    - 通过-e指定关注的事件	
        + perf top -e cache-misses -g -p pid	
    - 各函数cpu占用时间
        + perf top -g -p pid	
    - 记录perf结果并显示
        - perf record -g -e cpu-clock ./a
        - perf record -a -e cycles -o cycle.perf -g -p pid sleep 10 	
        - perf report -i cycle.perf | more
        - perf report -i cycle.perf > perf.txt	
    -  提供被调试程序运行的整体情况和汇总数据	
        + perf stat -p pid
```
Task-clock-msecs：CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO。
Context-switches：进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。
Cache-misses：程序运行过程中总体的 cache 利用情况，如果该值过高，说明程序的 cache 利用不好
CPU-migrations：表示进程 t1 运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行。
Cycles：处理器时钟，一条机器指令可能需要多个 cycles，
Instructions: 机器指令数目。
IPC：是 Instructions/Cycles 的比值，该值越大越好，说明程序充分利用了处理器的特性。
Cache-references: cache 命中的次数
Cache-misses: cache 失效的次数。
注：通过指定 -e 选项，您可以改变 perf stat 的缺省事件
```
#### gprof
* 说明
    - 只能使用静态连接libc库，否则在初始化*.so之前就调用profile代码会引起“segmentation fault”，解决办法是编译时加上-static-libgcc或-static。
    - 要监控到第三方库函数的执行时间，第三方库也必须是添加 –pg 选项编译的。
    - gprof 不支持多线程应用，多线程下只能采集主线程性能数据。原因是gprof采用ITIMER_PROF信号，在多线程内只有主线程才能响应该信号。但是有一个简单的方法可以解决这一问题:http://sam.zoy.org/writings/programming/gprof.html
    -  gprof只能在程序正常结束退出之后才能生成报告(gmon.out)
* 安装
    - apt-get install python3 graphviz pip
    - pip install gprof2dot
* 使用
    - 编译二进制
        * g++ -pg -O2 a.cpp -o a
    - 正常运行
        + ./a
    - 分析结果
        * gprof a > a.log
#### Gprof2dot
* 安装
    - apt-get install python3 graphviz pip
    - pip install gprof2dot
* perf分析输出转换为点图
    - perf script | c++filt | gprof2dot -f perf | dot -Tpng -o output.png
* gprof分析输出转换为点图
    - gprof2dot a.log | dot -Tpng -o output.png
<center>![Gprof2dot示例](https://www.5axxw.com/images_oss/cv/76df2ede-fa9f-4570-807c-1cb3f7b216d8.png?x-oss-process=style/logo)</center>