# 性能优化

### **业务优化**

业务逻辑结构优化能提升90%以上性能

### thread和corotine



corotine相较于thread可以有效减少线程切换时间，boost::asio就是使用协程实现。同时c++20中也有corotine的初步实现，corotine库第三方实现有[https://github.com/cloudwu/coroutine](https://github.com/cloudwu/coroutine)(云风大佬的c实现版本，很容易看懂原理)、[https://github.com/Tencent/libco](https://github.com/Tencent/libco)(腾讯的这个协程库好像有bug，内部版本修复了但是放出来的没修复)、[https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro)(感觉是最全面的)、[https://github.com/owent/libcopp](https://github.com/owent/libcopp)(使用boost::context实现)、[https://github.com/tearshark/librf](https://github.com/tearshark/librf)(和libgo很像)。

### 锁

尽量减少锁的使用，改用读写锁的地方用读写锁

### 无锁队列

线程和队列组成生产消费者模型，可以有效提升性能。队列中的锁是实现数据一致性的关键。multi-producer、multi-consumer模型下，锁的竞争其实是很大开销，所以有开启线程数等于cpu数这么一个说法。其他的解决方法包括但不限于无锁队列，使用原子操作CAS实现

### cpu绑定

目的是减少cachemiss

### cacheline

队列element大小设置cacheline，避免出现伪共享

### -O2优化

-O2优化的情况下会出现代码乱序执行的延伸问题，考虑使用内存屏障()

### 线程池

为了减少线程创建销毁的时间，适用于短小快速的任务。对于这种任务环境是不是可以考虑协程？

[内存池](%E5%86%85%E5%AD%98%E6%B1%A0/%E5%86%85%E5%AD%98%E6%B1%A0.md)

内存（memory）是在堆（heap）上分配的。当进程 （process）请求内存时是向堆（堆管理器）请求内存，而堆又向操作系统（OS）申请内存。由于这种操作代价比较大，操作系统一般是分配给一块（chunk）内存给堆，以减少内存操作（还是说系统调用）次数。因此进程调用delete或者free释放资源后，这些资源归还给了这个程序所申请到的堆，而堆不一定会将资源归还给操作系统（取决于操作系统类型、内存块的大小等因素）。这部分没有归还的资源在当前进程再次（使用new或malloc）申请内存时可以被重用，因此这样可以避免频繁与操作系统进行“内存交互”。这些释放的资源在进程结束后随着整个堆一起归还给OS。当然，如果想要强制回收资源也是有路子的，如博客中所说可以尝试malloc_trim。即使系统给我们做了优化，仍然可以使用内存池，减少该进程与自己chunk的交互，在进程内部减少new、delete所需的时间，适用于高频的内存new、delete使用环境中

[循环展开](%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80/%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80.md)

展开for循环减少for内部的判断逻辑达到优化目的



