# 成员指针作为模板参数

```C++
struct C { int foo; int bar; };
int C::*pmbr=nullptr;
pmbr=&C::foo;

template <typename R = void>
class MessageBus
{
public:
    template< class... Args, class F, class = typename std::enable_if<!std::is_member_function_pointer<F>::value>::type>
    void Attach(string strKey, F && f)
    {
      std::function<R(Args...)> fn = [&](Args... args) {return f(std::forward<Args>(args)...); };
      m_map.insert(std::make_pair(strKey + type_name < Args...>(), std::move(fn)));
    } 
    template<class... Args, class C, class... DArgs, class P>
    void Attach(string strKey, R(C::*f)(DArgs...), P && p)
    {
      std::function<R(Args...)> fn = [&, f](Args... args) {return (*p.*f)(std::forward<Args>(args)...); };
      m_map.insert(std::make_pair(strKey + type_name < Args...>(), std::move(fn)));
    }
    template<class... Args, class C, class... DArgs, class P>
    void Attach(string strKey, R(C::*f)(DArgs...) const, P && p)
    {
      std::function<R(Args...)> fn = [&, f](Args... args) {return (*p.*f)(std::forward<Args>(args)...); };
      m_map.insert(std::make_pair(strKey + type_name < Args...>(), std::move(fn)));
    }
private:
    std::multimap<string, boost::any> m_map;
}

struct A
{
  void Test(int x) { cout << x << endl; }
  void GTest()
  {
    cout << "it is a test" << endl;
  }
  void HTest(int x) const
  {
    cout << "it is a HTest" << endl;
  }
};

A a;
MessageBus<> bus;
bus.Attach<int>("aa", &A::Test, &a);
```


